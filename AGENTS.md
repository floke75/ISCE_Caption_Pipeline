# AGENTS.md - A Guide for LLM Agents

This document provides a high-level overview of the ISCE Captioning Pipeline repository, designed to be parsed by Large Language Model (LLM) agents. It outlines the purpose of each key file, their primary interactions, and the overall data flow.

## 1. Project Mission

The primary goal of this project is to provide a robust, non-black-box, and highly controllable pipeline for segmenting transcribed text into broadcast-quality subtitle blocks (`.srt` files). It replaces an inefficient LLM-based segmentation step with a specialized statistical model trained on human captioning patterns.

**Core Task:** Transform a time-stamped transcript into a perfectly segmented `.srt` file.

## 2. Architecture Snapshot

### 2.1 Orchestrator and Worker Scripts

- **`run_pipeline.py`** — Watches configured hot folders, launches `align_make.py`, `build_training_pair_standalone.py`, and `main.py` in sequence, and moves processed assets into archival locations to complete an inference run. Start here to understand the end-to-end workflow, especially the `process_inference_file` and `process_training_file` functions.
- **`align_make.py`** — Extracts audio, runs WhisperX plus diarization, and writes timestamped ASR JSON without touching text assets. Focus on `process_file` for the WhisperX workflow.
- **`build_training_pair_standalone.py`** — Aligns human text or SRT captions to ASR words, engineers linguistic features, and emits enriched JSON suitable for either inference or training. Examine `align_text_to_asr` for alignment logic and `engineer_features` for feature updates.
- **`main.py`** — Loads enriched tokens, statistical weights, and constraints before running the ISCE beam search and formatting SRT output. The heavy lifting occurs in `isce/beam_search.py` and `isce/scorer.py`.

### 2.2 Core ISCE Library (`isce/`)

Implements the segmentation engine:
- `beam_search.py` performs the constrained beam search over break decisions.
- `scorer.py` scores both local transitions and completed blocks using learned weights, rule-based boosts, and user “slider” settings.
- Supporting modules cover typed token structures, IO helpers, constraint derivation, and model building.

### 2.3 Model Training Utilities (`scripts/`)

- **`scripts/train_model.py`** — Aggregates enriched training corpora, derives fallback constraints, and performs iterative re-weighting to produce `model_weights.json` and `constraints.json`. Relies heavily on helpers in `isce/model_builder.py`.

### 2.4 UI Backend (`ui/backend/`)

- `app.py` exposes FastAPI routes for health checks, configuration management, job lifecycle, log streaming, and cancellation, serializing job metadata for the SPA.
- `pipelines.py` stages inputs in per-job workspaces, invokes the legacy CLI scripts, and records artifacts and results.
- `JobManager` persists job state, streams subprocess output, and materializes runtime configs via `ConfigService`, which also describes editable fields and configuration trees.
- `api/routes/files.py` powers the filesystem allowlist API used for safe browsing and validation of host paths.

### 2.5 Frontend SPA (`ui/frontend/`)

- Vite/React app rendering tabbed workflows (inference, training pair, model training, configuration) and a live job monitor.
- Forms post to the job endpoints, manage per-run overrides via `OverrideEditor`, and use `FilePathPicker` for validated path entry.
- `ConfigPanel` hydrates structured field metadata plus raw YAML overrides; `JobBoard` consumes `/api/jobs`, streams logs over SSE, and renders job details.
- `OverrideEditor` walks the configuration tree to coerce typed overrides, and `FilePathPicker` unifies root discovery, directory browsing, and debounced server-side validation for paths.

### 2.6 Frontend–Backend Integration Highlights

- **REST + SSE surface.** React hooks hit `/api/jobs`, `/api/jobs/{id}/logs`, and `/api/jobs/{id}/logs/stream`, aligning with FastAPI routes returning job metadata, tail logs, and server-sent events (including completion markers).
- **Configuration editing.** The SPA relies on `ConfigSnapshot` responses to populate structured forms and override editors, mapping field catalogs and schema trees generated by `ConfigService` on the backend.
- **Filesystem allowlist.** `FilePathPicker` consumes `/api/files/roots`, `/api/files/list`, and `/api/files/validate`, implemented by the backend’s `FileBrowser` to enforce path safety and surface breadcrumbs plus validation metadata.
- **Pipeline invocation.** Job creation endpoints accept payloads emitted by the forms (media/transcript paths, optional output overrides, per-run config patches) and hand them to `pipelines.py`, which mirrors the original CLI flow before recording outputs for the UI.

### 2.7 Known Alignment Gaps

- The inference form currently rejects output directories that do not already exist, while the backend happily creates missing directories. Consider relaxing the frontend validation to align with backend capabilities.
- Editable `project_root` and `pipeline_root` fields in the UI have no runtime effect because the backend overrides them. Update the UI to communicate this or adjust backend behavior if user overrides should be honored.

## 3. Data Flow Summary (Inference)

1. `MyVideo.mp4` + `MyVideo.txt` are placed in hot folders.
2. `run_pipeline.py` calls `align_make.py` with `MyVideo.mp4`.
3. `align_make.py` → `MyVideo.asr.visual.words.diar.json`.
4. `run_pipeline.py` calls `build_training_pair_standalone.py` with `MyVideo.txt` and the ASR JSON.
5. `build_training_pair_standalone.py` → `MyVideo.enriched.json`.
6. `run_pipeline.py` calls `main.py` with `MyVideo.enriched.json`.
7. `main.py` → `MyVideo.srt`.

This guide should provide a comprehensive starting point for any LLM agent tasked with analyzing or modifying this repository.
